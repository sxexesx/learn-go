## Стэк и куча

Память поделена на две части исторически. Куча начинается с начала, стек с конца. В protected area нельзя аллоцировать никакие объекты. Когда стек дорастает до protected area происходит stack overflow.  

<img src="./_src/pic_1.png">

Stack быстрее и свобождается автоматически и быстрее. Из кучи (heap) сами объекты не удаляются, нужно либо удалять руками, либо с помощью Garbage Collector. 

В стэке храняться недолго живущие локальные переменные. В куче храняться объекты и ссылки, которые живут за пределами функции.

## Как работает стэк в Go

Каждой горутине выделяется собственный стэк. Берется он у системы (syscom) в специальной области памяти, которую можно шарить между потоками. Стеки условно бесконечные (1GB - x64, 256Mb - x32), но базовый/начальный размер стека - 2Кб. 

<img src="./_src/pic_2.png">

**Stack pointer** - указатель, который показывает в каком состоянии сейчас находится стэк. В стеки записываются **function frame**, в которых указан возвращаемый адрес, адрес предыдущего фрейма, локальные переменные. 

Если runtime видит, что новый frame function переполяет базовые 2Кб, тогда он выделяет новую область памяти и копирует все старые function frame'ы и новый. Старый стек удаляется.

Как только функция заканчивает свое выполнение *stack pointer* перемещается к предыдущей функции(*foo()*). Область памяти помечается как `invalid memory`, но память остается и переменная еще жива. **Стек самостоятельное не чиститься!** Когда начинает выполняться новая функция, под нее выделяется таже память, что и под только что выполнившуюся функцию.

**Висячий указатель (dangling pointer)** — это указатель в программировании, указывающий на область памяти, которая была освобождена (удалена) или перераспределена. Он возникает, когда объект удаляют, но указатель не обнуляют, оставляя адрес «мусорным». Использование таких указателей приводит к непредсказуемому поведению программы, ошибкам сегментации и критическим уязвимостям. 

<img src="./_src/pic_3.png">

## Как узнать, где будет аллоцированная переменная? 

Не каждая переменная будет создана на стеке. За это отвечает **escape analysis**. 

**Escape Analysis** - это метод статического анализа, используемый *комилятором*, для определения где будет выделена память под переменную: стек или куча. 

Правила: 
1) Компилятор анализирует область видимости переменной и отслеживает, может ли указатель на неё выйти из текущей функции. Если нет, тогда переменная создается в стэке. 
2) Объект слишком большой, то он аллоцируется в куче
3) Не известно насколько большим объект вырастет в райнтайме
4) Если значение переменной передается в функцию как interface, эта переменная аллоцируется в куче
5) Литералы функций, структуры данных, принадлежащие мапам, слайсам, строкам и каналам

##  Есть ли разница, где аллоцировать функцию?

Да, есть. 
- в куче память аллоцируется дольше
- функции выполняются немного медленнее
- нагружает GC